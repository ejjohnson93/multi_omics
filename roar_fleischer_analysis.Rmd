# Analyis of Fleischer alternative polyadenylation data 

The following is an analysis of the PRJNA454681 dataset. The input files were generated by 'roar_fleischer_calculate.R' which determined the levels of alternative polyadenylation (APA) for each gene and the relative abundancies in TPM. APA is a potential regulator of type I collagen synthesis that's been poorly investigated. The aim was to investigate how this aspect of I collagen synthesis might be dysregulated in ageing and also to look at the ageing skin on a systemic level to see if pathways regulating ECM production are effected. There are two other related datasets that were analysed too, not included in this document. 

Load libraries

```{r}

library(tidyverse)

# Visualisation 
library(ggpmisc)
library(ggpubr)
library(RColorBrewer)

# Data analysis 
library(factoextra)
library(reshape)
library(pvca)
library(Biobase)
library(glmnet)
library(GSVA)
library(GSEABase)
library(limma)
library(gplots)


```

## Initial processing

Read in data:
('fleischer_sep_roar_results' contains both the APA and TPM data)

```{r}

data <- read.csv("fleischer_sep_roar_results.csv", header = TRUE)

```


```{r}

data <- as.matrix(data)

```

Read in meta-data data:

```{r}

metadata <- read.csv("fleischer_metadata.csv", header = TRUE)

```

Format data for preliminary analysis. First extract only columns with data.
Then convert matrix into a numeric type, before converting to dataframe. 
Add additional column with gene names.


```{r}

data_plain <- data[,c(1:136,139:274)]
mode(data_plain) = "numeric"
data_plain <- data.frame(data_plain)
data_plain$gene_ID <- data[,138]

```

Remove rows corresponding to NA values for gene names.
Then use gene names for rownames. 

```{r}

data_plain <- data_plain[!duplicated(data_plain$gene_ID), ]
data_plain <- data_plain[!is.na(data_plain$gene_ID), ]
rownames(data_plain) <- data_plain$gene_ID

```

Seperate the TPM data and ratio data. Filter the TPM data to exclude expression levels below 1. 
Use the newly fitlered TPM data to subset the ratio data (as the ratio data is unreliable for genes with low expression). 
Then further filter that ratio data to remove values below 0. 

```{r}

data_plain_TPM <- data_plain[,137:272]


for(i in 1:ncol(data_plain_TPM)){
    data_plain_TPM <- data_plain_TPM %>% filter(., .[i] > 2)
   
}



data_plain_ratio <- data_plain[,1:136]
data_plain_ratio <- data_plain_ratio[rownames(data_plain_ratio) %in% rownames(data_plain_TPM),]



for(i in 1:ncol(data_plain_ratio)){
    data_plain_ratio <- data_plain_ratio %>% filter(., .[i] > 0) 
   
}


```


Process the metadata file for use in analysis. Firstly, convert the HPS ages into numeric values (originally listed in yrs and month format), then convert the whole column into numeric values using 'as.numeric'. 

Next extract only the columns of interest for the analysis. Add an additional column to divide the samples into age groups for visualisation purposes. Make sure the HPS samples have their own unique identifier as their aged phenotype means they're more likely to resemble the old and middle-aged samples. 

```{r}
metadata_original <- metadata

metadata[127,2] <- 8
metadata[128,2] <- 8
metadata[129,2] <- 2.25
metadata[130,2] <- 3.75
metadata[131,2] <- 4.75
metadata[132,2] <- 8.5
metadata[133,2] <- 7
metadata[134,2] <- 5
metadata[135,2] <- 8.75
metadata[136,2] <- 3
metadata$age <- as.numeric(metadata$age)

metadata <- metadata %>% dplyr::select("Run", "age", "sex", "disease", "source_name", "ethnicity", "Instrument") %>% mutate(
    Age_group = case_when(
    age >= 60 ~ "Old",
    age > 30 & age < 60 ~ "Middle-aged",
    age <= 30 ~ "Young"
    ))

rownames(metadata) <- metadata$Run
metadata$Age_group[127:136] <- "HPS"

metadata$Age_group <- factor(metadata$Age_group, levels = c("Young", "Middle-aged", "Old", "HPS"))

```



Look at boxplots/distribution: 

The ratio values are log2 transformed before further analysis (though the raw values will be used for later collagen specific visualisation). This is to give the data better properties for statistical analysis, and shortening and lengthening of genes the same weight. A value of 0 is an equal ratio of short:long isoform. Values below 0 mean the long isoform is more prevalent. Values above zero mean the short isoform is more prevalent. 


```{r}

ratio_log <- log(data_plain_ratio, 2)
boxplot(ratio_log,ylab="Ratio",xlab="Sample")

```

The effect of log2 transforming the data can be seen with the density plots. It gives the data a normal distribution instead of a right-skewed one. It's also useful for highlighting that shorter isoforms seem to be more favoured in skin overall. 

```{r}

plot(density(ratio_log[,1]), ylim=c(0,0.3), xlim=c(-10,15))

for(i in 2:ncol(ratio_log)){ 
    lines(density(ratio_log[,i])) 

}

```

```{r}

young <- ratio_log[,metadata$Age_group == "Young"]
young <- melt(young)
young$variable <- "Young"


old <- ratio_log[,metadata$Age_group == "Old"]
old <- melt(old)
old$variable <- "Old"

density_data <- rbind(young, old)
colnames(density_data)[1] <- "Age group"


p_density_fleischer <- ggplot(density_data, aes(x=value, color=`Age group`, fill=`Age group`)) +
  geom_density(alpha=0.3,size=1)+ 
  labs(x= "Log2 ratio values", y= "Density")+
  ggtitle("Fleischer - PRJNA454681") + 
  theme_pubclean() + 
  scale_colour_brewer(palette = "Set1") 

p_density_fleischer


```

Younger samples tend to express shorter isoforms of genes, older samples tend to express longer isoforms of genes. 

```{r}

density(young$value)

```


```{r}

TPM_log <- log2(data_plain_TPM)
boxplot(TPM_log,ylab="TPM",xlab="Sample")

```

## Ratio results: 

### Exploratory analysis 

```{r}

pca_res <- prcomp(t(ratio_log), scale. = TRUE)

df_out <- as.data.frame(pca_res$x)
p1<-ggplot(df_out,aes(x=PC1,y=PC2,color=metadata$Age_group )) +
  geom_point() + 
  labs(color="Age Group") +
  theme_pubclean() 

p1

```

Calculate percentage of variance each PC contributes: 

```{r}

# Manually calculating 
pca.var <- pca_res$sdev^2
pca.var.per <- round(pca.var/sum(pca.var)*100, 1)

barplot(pca.var.per[1:20],
        main="Scree Plot - Top20 PCs",
        xlab="Principal Components",
        ylab="Percent Variation",
        names.arg = pca.var.per[1:20])

```

There is a package that makes exploratory analysis of multivariate data much more rapid: 

https://cran.r-project.org/web/packages/factoextra/readme/README.html

Using factoextra instead:

```{r}

fviz_eig(pca_res)

```

```{r}

fviz_pca_biplot(pca_res, repel = TRUE,
                col.var = "#2E9FDF", # Variables color
                col.ind = "#696969", # Individuals color
                )

```


```{r}

# Contributions of variables to PC1
PC1 <- fviz_contrib(pca_res, choice = "var", axes = 1, top = 30)
PC1

# Contributions of variables to PC2
PC2 <- fviz_contrib(pca_res, choice = "var", axes = 2, top = 30)
PC2

```

Visualise the top genes for PC1... 

First create a dataframe using the output of fviz_contrib. Arrange PC1 in descending order of contribution and extract the top genes. 
Pull the ratio data for all these genes from 'data_plain_ratio' and then merge together. Join with age data from the processed metadata. Then melt the dataframe with 'age' as one of the ID variables. 

```{r}

gene_list <- PC1[["data"]] %>% arrange(desc(contrib))
gene_list <- gene_list$name[1:16]

results <- list()


for(i in gene_list){
    print(i)

    results[[i]] <- t(as.data.frame(ratio_log))[1:126, i] #%>% dplyr::select(i)
}

# Bind together ratios for all samples, remove columns for treatment
results <- dplyr::bind_cols(results) %>% cbind.data.frame(., metadata$age[1:126])
results <- melt(results, id.vars = "metadata$age[1:126]")

colnames(results) <- c("Age", "Gene Name", "Ratio short:long isoform")

```

Visualise this data using ggplot2. 
Specify the formula of the linear model so the equation can be included on the graphs (function from ggpmisc). 
('stat_cor()' alternative way to do this)

Then use a facet grid to plot each of the top genes by age with a linear model fitted. 

```{r}

# Specify formula of linear model
my_formula <- y ~ x

# Create graph
p2 <- ggplot(results, aes(Age, `Ratio short:long isoform`, color = `Gene Name`)) +
  geom_point() +
  facet_wrap(~`Gene Name`) + 
  geom_smooth(method=lm, formula = my_formula) + 
  stat_poly_eq(formula = my_formula, 
                aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")), 
                parse = TRUE) + 
  theme_pubclean()

# Remove legend
p2 <- p2 + theme(legend.position = "none") + theme(plot.margin=grid::unit(c(3,3,3,3), "mm"))
p2

# Save figure
#ggsave("PC1_ratio.png", width = 9.7, height = 9.7, dpi = 300)
#ggsave("PC1_ratio.pdf", width = 9.5, height = 9.5, dpi = 300)

```

The R^2 value for all the linear models is relatively low (0.2 - 0.3. This is probably due to batch effects as PC2 accounts for a considerable portion of the variance. 
When PC2 was plotted in the same way the R^2 values were even lower (<0.01) so PC2 is definitely not an age related effect. 

Other genes of interest outside the top 16: GORAB, CISD2, EIF1 STRAP, YAF2 SMAD4, ENAH
Several are ageing related or ER proteins...

Plot GORAB:

```{r}

GORAB <- cbind.data.frame(t(ratio_log["GORAB",]),
               metadata$age,
               metadata$Age_group)

colnames(GORAB) <- c("GORAB short:long isoform ratio", "Age", "Age group")


ggplot(GORAB,
       aes(x=Age, y=`GORAB short:long isoform ratio`, color=`Age group`)) +
    geom_point() 

```

GORAB is interesting because the HPS samples are more similar to the middle-aged/old samples.
In geroderma osteodysplastica GORAB is mutated and skin becomes loose and wrinkly. Short isoforms of of mRNA generally escape regulation by miRNAs - could it be HPS patients express longer isoforms of GORAB? This might explain some of the similarities in phenotypes.

Additionally, GORAB is a golgi apparatus protein of unknown function - could it be affecting collagen synthesis/regulation? 

Publication: 

http://europepmc.org/article/MED/30631079

Current grant to elucidate function: 

https://gtr.ukri.org/projects?ref=MR%2FN000366%2F1


Plot summary results for the ratio data:

```{r}
ratio_graphs <- ggarrange(p1, p2, 
          labels = c("A", "B"),
          ncol = 1, nrow = 2, 
          heights = c(1.5, 4))

ratio_graphs

ggsave("ratio_data_new.png", width = 9.7, height = 15, dpi = 300)

```

Calculate genes with highest R^2 value for predicting age to see if there's overlap with PC1 results.

```{r}

gene_list <- rownames(ratio_log)

lm_results <- list()

# Create a linear model describing the realtionship with age for each gene 
# Extract the R^2 terms 
for(i in gene_list){
    #print(i)
  
    lm <- lm(metadata$age ~ as.numeric(ratio_log[i,]))
    lm <- summary(lm)
    lm_results[[i]] <- lm$adj.r.squared

}

lm_results <- t(dplyr::bind_cols(lm_results)) 
lm_results <- as.data.frame(lm_results) %>% arrange(desc(V1))


# Save the ordered R^2 values
write.csv(lm_results, "lm_results.csv")


# Create a file for the background genes
`%notin%` <- Negate(`%in%`)
lm_results <- lm_results[1:200,]
background <- rownames(ratio_log)[rownames(ratio_log) %notin% rownames(lm_results)]


write.csv(background, "lm_background.csv")

```



PVCA estimation of batch effects: 

(Code adapted from Liverpool's CBF's data science course)

```{r}

pheno_formatted <- new("AnnotatedDataFrame", data = metadata[,2:7])
ratio_data_formatted <- as.matrix(ratio_log)
colnames(ratio_data_formatted) <- gsub(pattern = "_.*",
                                       replacement = "",
                                       x = colnames(ratio_data_formatted))


PVCA_data <- ExpressionSet(assayData = ratio_data_formatted, phenoData = pheno_formatted)


pvcaObj <- pvcaBatchAssess(abatch = PVCA_data,
                           batch.factors = colnames(pheno_formatted@data),
                           threshold = 0.7)

pvca_res <- data.frame(as.data.frame(pvcaObj$label),
                       t(as.data.frame(pvcaObj$dat)))

colnames(pvca_res) <- c("effect", "variance")
pvca_res <- pvca_res[-nrow(pvca_res), ]


ggplot((pvca_res), aes(x= effect, y = variance)) +
    geom_bar(stat = 'identity', position = 'dodge', col ='transparent') +
    scale_fill_discrete(guide = 'none') +
    theme_bw(base_size = 16) +
    theme(plot.title = element_text(hjust=0.5),
          axis.text.x=element_text(angle=45,hjust=1)) +
    labs(x = 'Effects', y = 'Weighted average \n proportion variance') +
    ggtitle("PVCA estimation bar chart-non corrected data")


ggsave("PVCA_estimation.pdf", dpi = 300)


```

Two different instruments were used for sequencing and contribute a significant batch effect. Sex and ethnicity also contribute.


### GSVA analysis

Wanted to investigate what pathways are differentially regulated with age using APA and TPM data and extract any potentially relevant to type I collagen regulation. 

```{r}

annoGMT <- "c2.cp.v7.0.symbols.gmt.xz" 
annofile <- system.file("extdata", annoGMT, package="cogena")

gene_set <-getGmt(annofile,
                 geneIdType=SymbolIdentifier(),
                 collectionType=BroadCollection(category="h"))

            
```

```{r}

# All pathways
APA_gsva <- gsva(as.matrix(ratio_log),
                 gene_set,
                 method="gsva",
                 kcdf="Gaussian",
                 min.sz = 4,
                 parallel.sz=8
)

write.csv(APA_gsva, "./outputs/APA_gsva_all.csv")

```

Format data and quality check it. Remove HPS samples. 

```{r}

gsva_metadata <- metadata[metadata$Age_group != "HPS",]
#gsva_metadata$Age_group <- as.character(gsva_metadata$Age_group)
#gsva_metadata$Age_group <- as.factor(gsva_metadata$Age_group)

gsva_data  <- APA_gsva[,metadata$Age_group != "HPS"]
colnames(gsva_data) <- colnames(gsva_data) <-  gsub(pattern = "_.*",
                                    replacement = "",
                                    x = colnames(gsva_data))

colnames(gsva_data) == gsva_metadata$Run

```

Create model matrix and fit model:
Include sex, instrument and ethnicity as these are confounding variables.

```{r}

# Model matrix 
design <- model.matrix(~as.numeric(age)+as.factor(ethnicity)+as.factor(Instrument)+as.factor(sex), gsva_metadata)

# If I wanted to analyse data by 'age group' instead:
#design <- model.matrix(~0+Age_group+ethnicity+Instrument+sex, gsva_metadata)

# Fit model
fit <- lmFit(gsva_data, design)
fit2 <- eBayes(fit)

# Check what factors have differentially expressed genes 
summary(decideTests(fit2))

```

Extract genes with differential alternative polyadenylation: 

```{r}

tt <- topTable(fit2, coef=2, n=Inf)
pathway_data <- tt[tt$adj.P.Val <= 0.05,]
DEpwys <- rownames(tt)[tt$adj.P.Val <= 0.01]

write.csv(pathway_data, "differentially_expressed_pathways.csv")

```

Followed this tutorial: 

https://bioconductor.org/packages/release/bioc/vignettes/GSVA/inst/doc/GSVA.html#62_Differential_expression_at_pathway_level


```{r}

plot(tt$logFC, -log10(tt$P.Value), pch=".", cex=4, col=grey(0.75),
     main="", xlab="GSVA enrichment score difference", ylab=expression(-log[10]~~Raw~P-value))
abline(h=-log10(max(tt$P.Value[tt$adj.P.Val <= 0.01])), col=grey(0.5), lwd=1, lty=2)
points(tt$logFC[match(DEpwys, rownames(tt))],
       -log10(tt$P.Value[match(DEpwys, rownames(tt))]), pch=".", cex=5, col="darkred")
text(max(tt$logFC)*0.85, -log10(max(tt$P.Value[tt$adj.P.Val <= 0.01])), "1% FDR", pos=3)

```


```{r}

# Subset the GSVA ratio data by the differentially expressed pathways
DEpwys_es <- gsva_data[DEpwys, ]

# Remove pathway database prefixes
rownames(DEpwys_es) <- gsub("^KEGG_|^REACTOME_|^BIOCARTA_|^PID_", "", rownames(DEpwys_es))

# Remove some of the less relevant pathways
DEpwys_es <- DEpwys_es[rownames(DEpwys_es) != "PATHOGENIC_ESCHERICHIA_COLI_INFECTION",]
DEpwys_es <- DEpwys_es[rownames(DEpwys_es) != "PRION_DISEASES",]

# Create a heatmap
heatmap <- heatmap.2(as.matrix(DEpwys_es), 
          cexRow=0.85, cexCol=1,
          Rowv = T, Colv=T, 
          trace="none",
          dendrogram = "both",
          scale="column",
          col=bluered(100), 
          margins=c(7,30),
          hclustfun=function(d) hclust(d,method="ward.D2"))

indices <- heatmap[["colInd"]]

```


```{r}

young <- DEpwys_es[,gsva_metadata$Age_group == "Young"]
middle_aged <- DEpwys_es[,gsva_metadata$Age_group == "Middle-aged"]
old <- DEpwys_es[,gsva_metadata$Age_group == "Old"]


age_group_stratified <- t(rbind(rowMeans(young), rowMeans(middle_aged),rowMeans(old)))
colnames(age_group_stratified) <- c("Young", "Middle-aged", "Old")
#rownames(age_group_stratified) <- gsub("^KEGG_|^REACTOME_|^BIOCARTA_|^PID_", "", rownames(age_group_stratified))
#age_group_stratified <- age_group_stratified[-c(1,7,11),]

#(file = "myplot.png", bg = "transparent")

heatmap <- heatmap.2(as.matrix(age_group_stratified), 
          cexRow=0.90, cexCol=1,
          Rowv = T, Colv=T, 
          trace="none",
          dendrogram = "both",
          scale="column",
          col=bluered(100), 
          margins=c(7,31),
          hclustfun=function(d) hclust(d,method="ward.D2"))

#dev.off()

```

Plot some of the pathways of interest by age:

```{r}

COPI_DEPENDENT_GOLGI_TO_ER_RETROGRADE_TRAFFIC <- cbind.data.frame(gsva_data["REACTOME_COPI_DEPENDENT_GOLGI_TO_ER_RETROGRADE_TRAFFIC",],
               gsva_metadata$age,
               gsva_metadata$Age_group)

colnames(COPI_DEPENDENT_GOLGI_TO_ER_RETROGRADE_TRAFFIC) <- c("Enrichment", "Age", "Age group")


ggplot(COPI_DEPENDENT_GOLGI_TO_ER_RETROGRADE_TRAFFIC,
    aes(x=Age, y=`Enrichment`)) +
    geom_point() +
    theme_pubclean() + 
    scale_colour_brewer(palette = "Set1") + 
    theme(legend.position="right") +
    ggtitle("COPI-dependent Golgi-to-ER retrograde traffic")

```




### Predict age using alternative polyadenylation: 

Is alternative polyadenylation a useful predictor of age? Train an elastic net to determine age based off alternative polyadenylation of certain genes.


First prepare test and training data:
 
```{r}

set.seed(222)

# Remove the HPS samples as these are progeria samples and will skew results
labels <- metadata[metadata$Age_group != "HPS",]
data  <- t(ratio_log[,metadata$Age_group != "HPS"])

# Scale data for model
data <- scale(data, center = TRUE, scale = TRUE)

# Create indices to divide into test and training data
indices <- c(sample(1:length(labels$age), length(labels$age)*0.8))

# Test and train split 
x_train <- data[indices, ]
y_train <- labels$age[indices]
x_test <- data[-indices, ]
y_test <-labels$age[-indices]

```


Compare lasso, ridge and elastic net models. Optimise different values of alpha to do so. alpha = 0 is a ridge regression and alpha = 1 is a lasso regression. The values inbetween are elastic net regression models. 

Also optimise different values of lambda using cv.glmnet function. Code adapted from statquest video: 
https://github.com/StatQuest/ridge_lasso_elastic_net_demo/blob/master/ridge_lass_elastic_net_demo.R


```{r}

list_of_fits <- list()
for (i in 0:10) {

  fit_name <- paste0("alpha", i/10)
  
  list_of_fits[[fit_name]] <-
    cv.glmnet(x_train, y_train, type.measure="mse", alpha=i/10)
}


results <- data.frame()
for (i in 0:10) {
  fit_name <- paste0("alpha", i/10)
  
  # Use each model to predict 'y' given the Testing dataset
  predicted <- 
    predict(list_of_fits[[fit_name]], 
      s=list_of_fits[[fit_name]]$lambda.1se, newx=x_test)
  
  # Calculate the Mean Squared Error...
  mse <- mean((y_test - predicted)^2)
  
  # Store the results
  temp <- data.frame(alpha=i/10, mse=mse, fit_name=fit_name)
  results <- rbind(results, temp)
}

# View the results
results


```

```{r}

fit <- glmnet(x_train, y_train, alpha = 1, nlambda = list_of_fits$alpha0$lambda.min)

```

Very low accuracy. Try and remove batch effects, also improve random sampling of test and train. So far suggests APA isn't a useful biomarker for age - this might be expected as even the linear models with the best fits only had an R^2 of ~0.4 or so. 


## TPM results: 

Repeat roughly the same process with the TPM data... 

```{r}

pca_res <- prcomp(t(data_plain_TPM), scale. = TRUE)

df_out <- as.data.frame(pca_res$x)
p3<-ggplot(df_out,aes(x=PC1,y=PC2,color=metadata$Age_group )) +
  geom_point() + 
  labs(color="Age Group") +
  theme_pubclean() 

p3

```

```{r}

fviz_eig(pca_res)

```

```{r}

# Contributions of variables to PC1
PC1 <- fviz_contrib(pca_res, choice = "var", axes = 1, top = 30)
PC1

# Contributions of variables to PC2
PC2 <- fviz_contrib(pca_res, choice = "var", axes = 2, top = 30)
PC2

# Contributions of variables to PC3
PC3 <- fviz_contrib(pca_res, choice = "var", axes = 3, top = 30)
PC3

```

```{r}

gene_list <- PC1[["data"]] %>% arrange(desc(contrib))
gene_list <- gene_list$name[1:30]

results <- list()


for(i in gene_list){
    print(i)

    results[[i]] <- t(as.data.frame(data_plain_TPM))[1:126, i] #%>% dplyr::select(i)
}

# Bind together TPMs for all samples, remove columns for treatment
results <- dplyr::bind_cols(results) %>% cbind.data.frame(., metadata$age[1:126])
results <- melt(results, id.vars = "metadata$age[1:126]")

colnames(results) <- c("Age", "Gene Name", "TPM")

```

Visualise this data using ggplot2. 
Specify the formula of the linear model so the equation can be included on the graphs (function from ggpmisc). 

Then use a facet grid to plot each of the top genes by age with a linear model fitted. 

```{r}

# Specify formula of linear model
my_formula <- y ~ x

# Create graph
p4 <- ggplot(results, aes(Age, TPM, color = `Gene Name`)) +
  geom_point() +
  facet_wrap(~`Gene Name`) + 
  geom_smooth(method=lm, formula = my_formula) + 
  stat_poly_eq(formula = my_formula, 
                aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")), 
                parse = TRUE) + 
  theme_pubclean()

# Remove legend
p4 <- p4 + theme(legend.position = "none") + theme(plot.margin=grid::unit(c(3,3,3,3), "mm"))
p4

# Save figure
#ggsave("PC1_TPM.png", width = 9.7, height = 9.7, dpi = 300)
#ggsave("PC1_TPM.pdf", width = 9.5, height = 9.5, dpi = 300)

```

Calculate genes with highest R^2 value for predicting age to see if there's overlap with PC1 results.

```{r}

gene_list <- rownames(TPM_log)

lm_results <- list()

# Create a linear model describing the realtionship with age for each gene 
# Extract the R^2 terms 
for(i in gene_list){
    #print(i)
  
    lm <- lm(metadata$age ~ as.numeric(TPM_log[i,]))
    lm <- summary(lm)
    lm_results[[i]] <- lm$adj.r.squared

}

lm_results <- t(dplyr::bind_cols(lm_results)) 
lm_results <- as.data.frame(lm_results) %>% arrange(desc(V1))


# Save the ordered R^2 values
write.csv(lm_results, "TPM_lm_results.csv")


# Create a file for the background genes
`%notin%` <- Negate(`%in%`)
lm_results <- lm_results[1:200,]
background <- rownames(ratio_log)[rownames(ratio_log) %notin% rownames(lm_results)]


write.csv(background, "TPM_lm_background.csv")

```

Publications relating to genes of interest: 

https://genomebiology.biomedcentral.com/articles/10.1186/s13059-015-0750-x
https://www.researchgate.net/publication/306067867_PDCD4_is_a_CSL_associated_protein_with_a_transcription_repressive_function_in_cancer_associated_fibroblast_activation


In addition to investigating how the whole transcriptome is affected by ageing wanted to see how type I collagen specifically was affected.

### GSVA analysis


```{r}

# All pathways
TPM_gsva <- gsva(as.matrix(TPM_log),
                 gene_set,
                 method="gsva",
                 kcdf="Gaussian",
                 min.sz = 4,
                 parallel.sz=8
)

write.csv(TPM_gsva, "./outputs/TPM_gsva_all.csv")

```

Format data and quality check it. Remove HPS samples. 

```{r}

gsva_metadata <- metadata[metadata$Age_group != "HPS",]
#gsva_metadata$Age_group <- as.character(gsva_metadata$Age_group)
#gsva_metadata$Age_group <- as.factor(gsva_metadata$Age_group)

gsva_data  <- TPM_gsva[,metadata$Age_group != "HPS"]
colnames(gsva_data) <- colnames(gsva_data) <-  gsub(pattern = "_.*",
                                    replacement = "",
                                    x = colnames(gsva_data))

colnames(gsva_data) == gsva_metadata$Run

```

Create model matrix and fit model:

```{r}

# Model matrix 
design <- model.matrix(~as.numeric(age)+as.factor(ethnicity)+as.factor(Instrument)+as.factor(sex), gsva_metadata)

# If I wanted to analyse data by 'age group' instead:
#design <- model.matrix(~0+Age_group+ethnicity+Instrument+sex, gsva_metadata)

# Fit model
fit <- lmFit(gsva_data, design)
fit2 <- eBayes(fit)

# Check what factors have differentially expressed genes 
summary(decideTests(fit2))

```

Extract pathways with differential expression: 

```{r}

tt <- topTable(fit2, coef=2, n=Inf)
pathway_data <- tt[tt$adj.P.Val <= 0.05,]
DEpwys <- rownames(tt)[tt$adj.P.Val <= 0.01]

#write.csv(pathway_data, "TPM_differentially_expressed_pathways.csv")

```

```{r}

# Subset the GSVA ratio data by the differentially expressed pathways
DEpwys_es <- gsva_data[DEpwys, ]

# Remove pathway database prefixes
rownames(DEpwys_es) <- gsub("^KEGG_|^REACTOME_|^BIOCARTA_|^PID_", "", rownames(DEpwys_es))

# Create a heatmap
heatmap <- heatmap.2(as.matrix(DEpwys_es), 
          cexRow=0.85, cexCol=1,
          Rowv = T, Colv=T, 
          trace="none",
          dendrogram = "both",
          scale="column",
          col=bluered(100), 
          margins=c(7,30),
          hclustfun=function(d) hclust(d,method="ward.D2"))

indices <- heatmap[["colInd"]]

```

```{r}

young <- DEpwys_es[,gsva_metadata$Age_group == "Young"]
middle_aged <- DEpwys_es[,gsva_metadata$Age_group == "Middle-aged"]
old <- DEpwys_es[,gsva_metadata$Age_group == "Old"]


age_group_stratified <- t(rbind(rowMeans(young), rowMeans(middle_aged),rowMeans(old)))
colnames(age_group_stratified) <- c("Young", "Middle-aged", "Old")
#rownames(age_group_stratified) <- gsub("^KEGG_|^REACTOME_|^BIOCARTA_|^PID_", "", rownames(age_group_stratified))
#age_group_stratified <- age_group_stratified[-c(1,7,11),]

#(file = "myplot.png", bg = "transparent")

heatmap <- heatmap.2(as.matrix(age_group_stratified), 
          cexRow=0.90, cexCol=1,
          Rowv = T, Colv=T, 
          trace="none",
          dendrogram = "both",
          scale="column",
          col=bluered(100), 
          margins=c(7,31),
          hclustfun=function(d) hclust(d,method="ward.D2"))

#dev.off()

```


Look at intersection of Fleischer data and Kaisers data (load Kaisers data in if needed):

```{r}

all_pathways_fleischer <- rownames(pathway_data)

v <- venn(list(Fleischer = all_pathways_fleischer,
              Kaisers = all_pathways_kaisers))

v_int <- attr(v, "intersections")
pathways <- v_int$`Fleischer:Kaisers`

write.csv(pathways, "TPM_shared_pathways_fleisher_kaisers.csv")

```

Visualise collagen/ECM relevant pathways: 

```{r}

REACTOME_CROSSLINKING_OF_COLLAGEN_FIBRILS <- cbind.data.frame(gsva_data["REACTOME_CROSSLINKING_OF_COLLAGEN_FIBRILS",],
               gsva_metadata$age,
               gsva_metadata$Age_group)

colnames(REACTOME_CROSSLINKING_OF_COLLAGEN_FIBRILS) <- c("Enrichment", "Age", "Age group")

# Specify formula of linear model
my_formula <- y ~ x


p1 <- ggplot(REACTOME_CROSSLINKING_OF_COLLAGEN_FIBRILS,
    aes(x=Age, y=`Enrichment`)) +
    geom_point() +
    geom_smooth(method=lm, formula = my_formula) + 
    stat_poly_eq(formula = my_formula, 
                aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")), 
                parse = TRUE) + 
    theme_pubclean() + 
    scale_colour_brewer(palette = "Set1") + 
    theme(legend.position="right") +
    ggtitle("REACTOME CROSSLINKING OF COLLAGEN FIBRILS")

p1


```

```{r}

KEGG_CALCIUM_SIGNALING_PATHWAY <- cbind.data.frame(gsva_data["KEGG_CALCIUM_SIGNALING_PATHWAY",],
               gsva_metadata$age,
               gsva_metadata$Age_group)

colnames(KEGG_CALCIUM_SIGNALING_PATHWAY) <- c("Enrichment", "Age", "Age group")

# Specify formula of linear model
my_formula <- y ~ x


p2 <- ggplot(KEGG_CALCIUM_SIGNALING_PATHWAY,
    aes(x=Age, y=`Enrichment`)) +
    geom_point() +
    geom_smooth(method=lm, formula = my_formula) + 
    stat_poly_eq(formula = my_formula, 
                aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")), 
                parse = TRUE) + 
    theme_pubclean() + 
    scale_colour_brewer(palette = "Set1") + 
    theme(legend.position="right") +
    ggtitle("KEGG CALCIUM SIGNALING PATHWAY")

p2


```
```{r}
pathway_graphs <- ggarrange(p1, p2,
          labels = c("A", "B"),
          ncol = 1, nrow = 2)

pathway_graphs

ggsave("fleisher_tpm_pathways.png", dpi = 300, width = 8.5, height = 12) 

```

## Extract collagen specific data:

Looked at skin ageing from a systemic perspective, now extract the collagen specific data - since that's of greatest interest for the project. 

```{r}

genes <- cbind.data.frame(t(data_plain_ratio["COL1A2",1:126]),
               t(data_plain_ratio["COL1A1",1:126]),
               metadata$age[1:126])

genes <- melt(genes, id.vars = "metadata$age[1:126]")


colnames(genes) <- c("Age", "Gene Name", "Ratio short:long isoform")


fleischer_p1 <- ggplot(genes, aes(x=Age, y=`Ratio short:long isoform`, color=`Gene Name`)) + 
    geom_point() + 
    geom_smooth(method=lm) +
    theme_pubclean() + 
    scale_colour_brewer(palette = "Set1") + 
    theme(legend.position="right") +
    ggtitle("Fleischer - PRJNA454681")

fleischer_p1

```

```{r}

genes <- cbind.data.frame(t(data_plain_TPM["COL1A2",1:126]),
               t(data_plain_TPM["COL1A1",1:126]),
               metadata$age[1:126])

genes <- melt(genes, id.vars = "metadata$age[1:126]")


colnames(genes) <- c("Age", "Gene Name", "Transcripts per million (TPM)")


p6 <- ggplot(genes, aes(x=Age, y=`Transcripts per million (TPM)`, color=`Gene Name`)) + 
    geom_point() + 
    geom_smooth(method=lm) +
    theme_pubclean() + 
    scale_colour_brewer(palette = "Set1")

p6

```


```{r}

COL1A1 <- data_plain["COL1A1",-ncol(data_plain)]
COL1A2 <- data_plain["COL1A2",-ncol(data_plain)]

col_df <- t(rbind(COL1A1, COL1A2))

ratio <- as.data.frame(col_df[grepl("ratio", rownames(col_df)), ])
TPM <- as.data.frame(col_df[grepl("TPM", rownames(col_df)), ])

rownames(TPM) <-  gsub(pattern = "_.*",
                                    replacement = "",
                                    x = rownames(TPM))

rownames(ratio) <- gsub(pattern = "_.*",
                                    replacement = "",
                                    x = rownames(ratio))

col_df <- cbind(TPM, ratio)
colnames(col_df) <- c("COL1A1_TPM", "COL1A2_TPM", "COL1A1_ratio", "COL1A2_ratio")


```


```{r}

col_df <- col_df %>% mutate(
    COL1A1_short_form = COL1A1_TPM/(COL1A1_ratio+1)*COL1A1_ratio,
    COL1A1_long_form = COL1A1_TPM/(COL1A1_ratio+1),
    COL1A2_short_form = COL1A2_TPM/(COL1A2_ratio+1)*COL1A2_ratio,
    COL1A2_long_form = COL1A2_TPM/(COL1A2_ratio+1)) %>% add_column(metadata$Age_group, metadata$sex)

# (round(test$COL1A2_long_form) + round(test$COL1A2_short_form)) == round(test$COL1A2_TPM)

```


```{r}

write.csv(col_df, "./fleischer_collagen_data.csv")

```



Next convert into long format for ggplot2 format: 

```{r}

for(i in 1:8){
    col_df_melt <- col_df %>% filter(., .[i] > 0)
   
}

col_df_melt <- col_df[5:9]
colnames(col_df_melt)[5] <- "age_group"


```

```{r}

## COL1A1 

col1a1_melt <- col_df_melt[,c(1,2,5)]
col1a1_melt <- melt(col1a1_melt, id.vars = "age_group")


col1a1_melt$variable <- str_replace(col1a1_melt$variable, "COL1A1_short_form", "Short")
col1a1_melt$variable <- str_replace(col1a1_melt$variable, "COL1A1_long_form", "Long")
col1a1_melt["Collagen"] <- "COL1A1"


## COL1A2

col1a2_melt <- col_df_melt[,c(3,4,5)]
col1a2_melt <- melt(col1a2_melt, id.vars = "age_group")


col1a2_melt$variable <- str_replace(col1a2_melt$variable, "COL1A2_short_form", "Short")
col1a2_melt$variable <- str_replace(col1a2_melt$variable, "COL1A2_long_form", "Long")
col1a2_melt["Collagen"] <- "COL1A2"


## Join and format

col_df_melt_2 <- rbind(col1a1_melt, col1a2_melt)
colnames(col_df_melt_2)[1:3] <- c("age_group", "Isoform", "Transcripts per million (TPM)")
#col_df_melt_2$`Tissue type` <- factor(col_df_melt_2$`Tissue type`, levels=c("Normal", "Breast cancer"))
col_df_melt_2$Isoform <- factor(col_df_melt_2$Isoform, levels=c("Long", "Short"))


col_df_melt_2 <- col_df_melt_2[col_df_melt_2$age_group != "HPS",]

```


```{r}

fleischer_p2 <- ggbarplot(col_df_melt_2, x = "Collagen", y = "Transcripts per million (TPM)", add = c("mean_se"), fill = "Isoform", facet.by = "age_group") + 
    scale_fill_brewer(palette="Set1") + 
    theme_pubclean() +
    theme(legend.position="right") + 
    theme(axis.title.y = element_text(margin = margin(t = 0, r = 7, b = 0, l = 0))) +
    theme(axis.text.x = element_text(angle = 45))

fleischer_p2

```

Combine with Kaisers and Jung analysis (carried out seperately):

```{r}
density_graphs <- ggarrange(p_density_fleischer, p_density_kaisers, p_density_jung,
          labels = c("A", "B", "C"),
          ncol = 3, nrow = 1)

density_graphs 

ggsave("density_data.pdf", dpi = 300) 
ggsave("density__data.png", dpi = 300, width = 9.5, height = 5) 

```

```{r}
collagen_graphs <- ggarrange(fleischer_p1, fleischer_p2, kaisers_p1, kaisers_p2, jung_p1, jung_p2,
          labels = c("A", "B", "C", "D", "E", "F"),
          ncol = 2, nrow = 3)

collagen_graphs 

ggsave("kaisers_fleischer_jung_data.pdf", dpi = 300, width = 9.5, height = 12) 
ggsave("kaisers_fleischer_jung_data.png", dpi = 300, width = 8.5, height = 12) 

```
